# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2022-07-11T21:04:55+00:00
from __future__ import annotations

from datetime import date
from datetime import datetime
from enum import Enum
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from uuid import UUID

from pydantic import AnyUrl
from pydantic import BaseModel
from pydantic import confloat
from pydantic import conint
from pydantic import constr
from pydantic import EmailStr
from pydantic import Field
from pydantic import PositiveFloat
from pydantic import PositiveInt


class Role(Enum):
    admin = "admin"
    provider = "provider"
    customer = "customer"


class AttachUserPayload(BaseModel):
    role: Role = Field(..., title="Role")
    user_id: UUID = Field(..., title="User Id")


class BodyLoginAccessTokenApiV1LoginAccessTokenPost(BaseModel):
    grant_type: Optional[constr(regex=r"password")] = Field(None, title="Grant Type")
    username: str = Field(..., title="Username")
    password: str = Field(..., title="Password")
    scope: Optional[str] = Field("", title="Scope")
    client_id: Optional[str] = Field(None, title="Client Id")
    client_secret: Optional[str] = Field(None, title="Client Secret")


class BodyResetPasswordApiV1ResetPasswordEmailPost(BaseModel):
    code: str = Field(..., title="Code")
    new_password: str = Field(..., title="New Password")


class Callback(BaseModel):
    type: Optional[str] = Field("http", title="Type")
    url: Optional[str] = Field(
        None,
        description="User-configured publicly callable HTTP endpoint for notifications regarding request updates",
        title="Url",
    )
    tags: Optional[List[str]] = Field([], max_items=5, title="Tags")


class CancelRequestArchivePayload(BaseModel):
    results: List[UUID] = Field(..., min_items=1, title="Results")


class Tier(Enum):
    archive = "archive"
    tasking = "tasking"


class CreatePricePayload(BaseModel):
    source_id: UUID = Field(
        ...,
        description="ID of the satellite or constellation considered for the price",
        title="Source Id",
    )
    price: PositiveFloat = Field(
        ..., description="Price per square kilometer in USD", title="Price"
    )
    tier: Tier = Field(..., title="Tier")
    min_age: conint(ge=0) = Field(
        ...,
        description="Minimum age of an ordered product since capture to have this price",
        title="Min Age",
    )
    max_age: Optional[PositiveInt] = Field(
        None,
        description="Maximum age of an product since capture to have this price",
        title="Max Age",
    )


class SensorType(Enum):
    optical = "optical"
    sar = "sar"


class SensorType1(Enum):
    optical = "optical"
    sar = "sar"


class CreateSourcePayload(BaseModel):
    name: str = Field(
        ..., description="Name of the satellite or constellation", title="Name"
    )
    bands: Optional[str] = Field(
        None,
        description="An ordered list of bands offered by the source",
        title="Bands",
    )
    resolution: PositiveFloat = Field(
        ..., description="Resolution in meters per pixel", title="Resolution"
    )
    sensor_type: SensorType1 = Field(
        ..., description="Type of the sensor", title="Sensor Type"
    )


class CursorPaginationResponse(BaseModel):
    next_cursor: Optional[str] = Field(
        None,
        description="The next cursor to fetch more results or null if there's no more results",
        title="Next Cursor",
    )
    total: Optional[int] = Field(
        None, description="The total number of items", title="Total"
    )


class Role1(Enum):
    admin = "admin"
    provider = "provider"
    customer = "customer"


class DetachUserPayload(BaseModel):
    role: Role1 = Field(..., title="Role")
    user_id: UUID = Field(..., title="User Id")


class Country(Enum):
    AFG = "AFG"
    ALA = "ALA"
    ALB = "ALB"
    DZA = "DZA"
    ASM = "ASM"
    AND = "AND"
    AGO = "AGO"
    AIA = "AIA"
    ATA = "ATA"
    ATG = "ATG"
    ARG = "ARG"
    ARM = "ARM"
    ABW = "ABW"
    AUS = "AUS"
    AUT = "AUT"
    AZE = "AZE"
    BHS = "BHS"
    BHR = "BHR"
    BGD = "BGD"
    BRB = "BRB"
    BLR = "BLR"
    BEL = "BEL"
    BLZ = "BLZ"
    BEN = "BEN"
    BMU = "BMU"
    BTN = "BTN"
    BOL = "BOL"
    BES = "BES"
    BIH = "BIH"
    BWA = "BWA"
    BVT = "BVT"
    BRA = "BRA"
    IOT = "IOT"
    VGB = "VGB"
    BRN = "BRN"
    BGR = "BGR"
    BFA = "BFA"
    BDI = "BDI"
    CPV = "CPV"
    KHM = "KHM"
    CMR = "CMR"
    CAN = "CAN"
    CYM = "CYM"
    CAF = "CAF"
    TCD = "TCD"
    CHL = "CHL"
    CHN = "CHN"
    HKG = "HKG"
    MAC = "MAC"
    CXR = "CXR"
    CCK = "CCK"
    COL = "COL"
    COM = "COM"
    COG = "COG"
    COK = "COK"
    CRI = "CRI"
    CIV = "CIV"
    HRV = "HRV"
    CUB = "CUB"
    CUW = "CUW"
    CYP = "CYP"
    CZE = "CZE"
    PRK = "PRK"
    COD = "COD"
    DNK = "DNK"
    DJI = "DJI"
    DMA = "DMA"
    DOM = "DOM"
    ECU = "ECU"
    EGY = "EGY"
    SLV = "SLV"
    GNQ = "GNQ"
    ERI = "ERI"
    EST = "EST"
    SWZ = "SWZ"
    ETH = "ETH"
    FLK = "FLK"
    FRO = "FRO"
    FJI = "FJI"
    FIN = "FIN"
    FRA = "FRA"
    GUF = "GUF"
    PYF = "PYF"
    ATF = "ATF"
    GAB = "GAB"
    GMB = "GMB"
    GEO = "GEO"
    DEU = "DEU"
    GHA = "GHA"
    GIB = "GIB"
    GRC = "GRC"
    GRL = "GRL"
    GRD = "GRD"
    GLP = "GLP"
    GUM = "GUM"
    GTM = "GTM"
    GGY = "GGY"
    GIN = "GIN"
    GNB = "GNB"
    GUY = "GUY"
    HTI = "HTI"
    HMD = "HMD"
    VAT = "VAT"
    HND = "HND"
    HUN = "HUN"
    ISL = "ISL"
    IND = "IND"
    IDN = "IDN"
    IRN = "IRN"
    IRQ = "IRQ"
    IRL = "IRL"
    IMN = "IMN"
    ISR = "ISR"
    ITA = "ITA"
    JAM = "JAM"
    JPN = "JPN"
    JEY = "JEY"
    JOR = "JOR"
    KAZ = "KAZ"
    KEN = "KEN"
    KIR = "KIR"
    KWT = "KWT"
    KGZ = "KGZ"
    LAO = "LAO"
    LVA = "LVA"
    LBN = "LBN"
    LSO = "LSO"
    LBR = "LBR"
    LBY = "LBY"
    LIE = "LIE"
    LTU = "LTU"
    LUX = "LUX"
    MDG = "MDG"
    MWI = "MWI"
    MYS = "MYS"
    MDV = "MDV"
    MLI = "MLI"
    MLT = "MLT"
    MHL = "MHL"
    MTQ = "MTQ"
    MRT = "MRT"
    MUS = "MUS"
    MYT = "MYT"
    MEX = "MEX"
    FSM = "FSM"
    MCO = "MCO"
    MNG = "MNG"
    MNE = "MNE"
    MSR = "MSR"
    MAR = "MAR"
    MOZ = "MOZ"
    MMR = "MMR"
    NAM = "NAM"
    NRU = "NRU"
    NPL = "NPL"
    NLD = "NLD"
    NCL = "NCL"
    NZL = "NZL"
    NIC = "NIC"
    NER = "NER"
    NGA = "NGA"
    NIU = "NIU"
    NFK = "NFK"
    MKD = "MKD"
    MNP = "MNP"
    NOR = "NOR"
    OMN = "OMN"
    PAK = "PAK"
    PLW = "PLW"
    PAN = "PAN"
    PNG = "PNG"
    PRY = "PRY"
    PER = "PER"
    PHL = "PHL"
    PCN = "PCN"
    POL = "POL"
    PRT = "PRT"
    PRI = "PRI"
    QAT = "QAT"
    KOR = "KOR"
    MDA = "MDA"
    REU = "REU"
    ROU = "ROU"
    RUS = "RUS"
    RWA = "RWA"
    BLM = "BLM"
    SHN = "SHN"
    KNA = "KNA"
    LCA = "LCA"
    MAF = "MAF"
    SPM = "SPM"
    VCT = "VCT"
    WSM = "WSM"
    SMR = "SMR"
    STP = "STP"
    SAU = "SAU"
    SEN = "SEN"
    SRB = "SRB"
    SYC = "SYC"
    SLE = "SLE"
    SGP = "SGP"
    SXM = "SXM"
    SVK = "SVK"
    SVN = "SVN"
    SLB = "SLB"
    SOM = "SOM"
    ZAF = "ZAF"
    SGS = "SGS"
    SSD = "SSD"
    ESP = "ESP"
    LKA = "LKA"
    PSE = "PSE"
    SDN = "SDN"
    SUR = "SUR"
    SJM = "SJM"
    SWE = "SWE"
    CHE = "CHE"
    SYR = "SYR"
    TJK = "TJK"
    THA = "THA"
    TLS = "TLS"
    TGO = "TGO"
    TKL = "TKL"
    TON = "TON"
    TTO = "TTO"
    TUN = "TUN"
    TUR = "TUR"
    TKM = "TKM"
    TCA = "TCA"
    TUV = "TUV"
    UGA = "UGA"
    UKR = "UKR"
    ARE = "ARE"
    GBR = "GBR"
    TZA = "TZA"
    UMI = "UMI"
    USA = "USA"
    VIR = "VIR"
    URY = "URY"
    UZB = "UZB"
    VUT = "VUT"
    VEN = "VEN"
    VNM = "VNM"
    WLF = "WLF"
    ESH = "ESH"
    YEM = "YEM"
    ZMB = "ZMB"
    ZWE = "ZWE"


class FirstLoginPayload(BaseModel):
    email: EmailStr = Field(..., title="Email")
    old_password: str = Field(..., title="Old Password")
    new_password: str = Field(..., title="New Password")
    full_name: str = Field(..., title="Full Name")
    phone_number: Optional[constr(regex=r"(^\+?\d{5,15}$)|^$")] = Field(
        None, title="Phone Number"
    )
    country: Optional[Country] = Field(None, title="Country")


class Role2(Enum):
    admin = "admin"
    provider = "provider"
    customer = "customer"


class InviteUserPayload(BaseModel):
    email: EmailStr = Field(..., title="Email")
    resend: Optional[bool] = Field(False, title="Resend")
    roles: List[Role2] = Field(..., title="Roles", unique_items=True)


class Link(BaseModel):
    href: AnyUrl = Field(
        ..., description="Url to the additional resource", title="Href"
    )
    method: str = Field(
        ..., description="Http method to call the additional resource", title="Method"
    )


class Msg(BaseModel):
    msg: str = Field(..., title="Msg")


class OnBehalfOf(BaseModel):
    name: constr(min_length=1) = Field(..., title="Name")
    email: EmailStr = Field(..., title="Email")
    affiliation: Optional[constr(min_length=2)] = Field(None, title="Affiliation")
    address: Optional[constr(min_length=1)] = Field(None, title="Address")
    country: Optional[constr(min_length=3)] = Field(None, title="Country")
    application_fields: Optional[List[str]] = Field(
        [], max_items=10, title="Application Fields"
    )
    phone_no: Optional[constr(min_length=7)] = Field(None, title="Phone No")
    division: Optional[constr(min_length=2)] = Field(None, title="Division")
    position: Optional[constr(min_length=3)] = Field(None, title="Position")


class OrderType(Enum):
    archive = "archive"
    tasking = "tasking"


class OrderInfo(BaseModel):
    order_type: Optional[OrderType] = Field(
        None, description="The type of the order", title="Order Type"
    )
    result_id: Optional[UUID] = Field(
        None,
        description="Unique identifier for the result associated with this transaction",
        title="Result Id",
    )
    request_id: Optional[UUID] = Field(
        None,
        description="Unique identifier for the request associated with this transaction",
        title="Request Id",
    )


class OrderRequestArchivePayload(BaseModel):
    results: List[UUID] = Field(..., min_items=1, title="Results")


class OutputTasking(BaseModel):
    multi_product: Optional[bool] = Field(
        True,
        description="The request can receive one result that covers the entire area of interest if multi_product=false or multiple results if avaialable",
        title="Multi product delivery",
    )


class PolygonGeom(BaseModel):
    type: Optional[str] = Field(None, title="Type")
    coordinates: List[List[List[float]]] = Field(..., title="Coordinates")


class PolygonGeomResponse(BaseModel):
    type: Optional[str] = Field(None, title="Type")
    coordinates: List[List[List[float]]] = Field(..., title="Coordinates")
    bbox: List[float] = Field(..., title="Bbox")


class Tier1(Enum):
    archive = "archive"
    tasking = "tasking"


class PriceResponse(BaseModel):
    source_id: UUID = Field(
        ...,
        description="ID of the satellite or constellation considered for the price",
        title="Source Id",
    )
    price: PositiveFloat = Field(
        ..., description="Price per square kilometer in USD", title="Price"
    )
    tier: Tier1 = Field(..., title="Tier")
    min_age: conint(ge=0) = Field(
        ...,
        description="Minimum age of an ordered product since capture to have this price",
        title="Min Age",
    )
    max_age: Optional[PositiveInt] = Field(
        None,
        description="Maximum age of an product since capture to have this price",
        title="Max Age",
    )
    id: UUID = Field(..., title="Id")
    deleted: Optional[bool] = Field(
        False,
        description="Indicates if the price object has been deactivated (not in use)",
        title="Deleted",
    )
    created_at: Optional[datetime] = Field(None, title="Created At")
    updated_at: Optional[datetime] = Field(None, title="Updated At")


class ProductResponse(BaseModel):
    id: UUID = Field(..., title="Id")
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry", title="Geometry"
    )
    source_id: UUID = Field(
        ...,
        description="ID of the satellite or constellation that captured the product",
        title="Source Id",
    )
    name: str = Field(..., description="Product name", title="Name")
    area_km2: Optional[confloat(ge=0.0)] = Field(
        None,
        description="Size of the product's area in square kilometers",
        title="Area Km2",
    )
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Cloud cover percentage of the product's area",
        title="Cloud Cover Percent",
    )
    capture_ts: datetime = Field(
        ..., description="Capture timestamp of the product", title="Capture Ts"
    )
    capture_date: date = Field(
        ..., description="Capture date of the product", title="Capture Date"
    )
    preview_download_url: Optional[str] = Field(
        None, description="Preview URL of the product", title="Preview Download Url"
    )
    thumbnail_download_url: Optional[str] = Field(
        None, description="Thumbnail URL of the product", title="Thumbnail Download Url"
    )
    height_pixels: Optional[PositiveInt] = Field(
        None, description="Height in pixels of the actual image", title="Height Pixels"
    )
    width_pixels: Optional[PositiveInt] = Field(
        None, description="Width in pixels of the actual image", title="Width Pixels"
    )
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")
    level: Optional[str] = Field(
        None, description="Remote sensing imagery processing level", title="Level"
    )
    source_name: Optional[str] = Field(
        None,
        description="Name of the satellite or constellation that captured the product",
        title="Source Name",
    )
    resolution: PositiveFloat = Field(
        ..., description="Resolution in meters per pixel", title="Resolution"
    )


class Type(Enum):
    archive = "archive"
    tasking = "tasking"


class RequestArchive(BaseModel):
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry", title="Geometry"
    )
    id: UUID = Field(..., title="Id")
    start_date: date = Field(
        ..., description="Earliest allowable date of capture", title="Start Date"
    )
    end_date: date = Field(
        ..., description="Latest allowable date of capture", title="End Date"
    )
    area_km2: PositiveFloat = Field(
        ..., description="Geometry area in square kilometers", title="Area Km2"
    )
    fulfilled_area_km2: Optional[PositiveFloat] = Field(
        None,
        description="Total area in square kilometers of all results that fulfill the request",
        title="Fulfilled Area Km2",
    )
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")
    callback: Optional[Callback] = Field(
        None,
        description="JSON object that contains information on where to push notifications for any updates on the request",
        title="Callback",
    )
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        20,
        description="Maximum allowable cloud cover percentage",
        title="Cloud Cover Percent",
    )
    hidden: bool = Field(..., title="Hidden")
    user_id: UUID = Field(..., title="User Id")
    on_behalf_of: Optional[OnBehalfOf] = None
    tags: Optional[Dict[str, Any]] = Field(
        {}, description="Custom key-value pairs for tagging and filtering", title="Tags"
    )
    status: Optional[str] = Field(
        None,
        description="Archive requests will always have the `quoted` status",
        title="Status",
    )
    min_resolution: Optional[PositiveFloat] = Field(
        None,
        description="Least allowable resolution in meters per pixel",
        title="Min Resolution",
    )
    max_resolution: Optional[PositiveFloat] = Field(
        None,
        description="Best allowable resolution in meters per pixel",
        title="Max Resolution",
    )
    payment_total: Optional[confloat(ge=0.0)] = Field(
        None,
        description="Total price (USD) of all the ordered results that fulfilled the request.",
        title="Payment Total",
    )


class RequestArchiveResponse(BaseModel):
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry", title="Geometry"
    )
    id: UUID = Field(..., title="Id")
    start_date: date = Field(
        ..., description="Earliest allowable date of capture", title="Start Date"
    )
    end_date: date = Field(
        ..., description="Latest allowable date of capture", title="End Date"
    )
    area_km2: PositiveFloat = Field(
        ..., description="Geometry area in square kilometers", title="Area Km2"
    )
    fulfilled_area_km2: Optional[PositiveFloat] = Field(
        None,
        description="Total area in square kilometers of all results that fulfill the request",
        title="Fulfilled Area Km2",
    )
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")
    callback: Optional[Callback] = Field(
        None,
        description="JSON object that contains information on where to push notifications for any updates on the request",
        title="Callback",
    )
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        20,
        description="Maximum allowable cloud cover percentage",
        title="Cloud Cover Percent",
    )
    hidden: bool = Field(..., title="Hidden")
    user_id: UUID = Field(..., title="User Id")
    on_behalf_of: Optional[OnBehalfOf] = None
    tags: Optional[Dict[str, Any]] = Field(
        {}, description="Custom key-value pairs for tagging and filtering", title="Tags"
    )
    status: Optional[str] = Field(
        None,
        description="Archive requests will always have the `quoted` status",
        title="Status",
    )
    min_resolution: Optional[PositiveFloat] = Field(
        None,
        description="Least allowable resolution in meters per pixel",
        title="Min Resolution",
    )
    max_resolution: Optional[PositiveFloat] = Field(
        None,
        description="Best allowable resolution in meters per pixel",
        title="Max Resolution",
    )
    payment_total: Optional[confloat(ge=0.0)] = Field(
        None,
        description="Total price (USD) of all the ordered results that fulfilled the request.",
        title="Payment Total",
    )
    results_count: Optional[int] = Field(
        None,
        description="Number of results found for this request",
        title="Results Count",
    )


class Status(Enum):
    quoted = "quoted"
    pending_approval = "pending_approval"
    approved = "approved"
    declined = "declined"
    expired = "expired"
    collection_scheduled = "collection_scheduled"
    collection_cancelled = "collection_cancelled"
    collection_in_progress = "collection_in_progress"
    collected = "collected"
    collection_failed = "collection_failed"
    processing = "processing"
    processing_failed = "processing_failed"
    processing_cancelled = "processing_cancelled"
    fulfilled = "fulfilled"


class Status1(Enum):
    ready_to_order = "ready_to_order"
    pending_approval = "pending_approval"
    declined = "declined"
    approved = "approved"
    processing = "processing"
    processing_cancelled = "processing_cancelled"
    processing_failed = "processing_failed"
    fulfilled = "fulfilled"


class OrderState(Enum):
    not_ordered = "not_ordered"
    ordering = "ordering"
    ordered = "ordered"
    order_declined = "order_declined"
    cancelling = "cancelling"
    cancelled = "cancelled"
    cancellation_declined = "cancellation_declined"


class ResultArchiveResponse(BaseModel):
    id: UUID = Field(..., title="Id")
    intersection_percent_coverage: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Percentage of the request AOI covered by the result",
        title="Intersection Percent Coverage",
    )
    intersection_cloud_percentage: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Percentage of clouds in the request AOI of matching product",
        title="Intersection Cloud Percentage",
    )
    intersection_area_km2: PositiveFloat = Field(
        ...,
        description="Intersection area in square kilometers between the matching product and the request AOI",
        title="Intersection Area Km2",
    )
    price: confloat(ge=0.0) = Field(
        ..., description="Price (USD) of the result", title="Price"
    )
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")
    thumbnail_download_url: Optional[str] = Field(
        None, description="Thumbnail URL of the result", title="Thumbnail Download Url"
    )
    preview_download_url: Optional[str] = Field(
        None, description="Preview URL of the result", title="Preview Download Url"
    )
    intersection_geometry: PolygonGeom = Field(
        ...,
        description="Intersection geometry between the matching product and the search AOI",
        title="Intersection Geometry",
    )
    capture_date: date = Field(
        ..., description="Capture date of the result", title="Capture Date"
    )
    source_name: str = Field(
        ...,
        description="Name of the satellite or constellation that captured the product",
        title="Source Name",
    )
    request_id: UUID = Field(..., description="Request id", title="Request Id")
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Cloud cover percentage of the product's area",
        title="Cloud Cover Percent",
    )
    product_name: str = Field(..., description="Product name", title="Product Name")
    capture_ts: datetime = Field(
        ..., description="Capture timestamp of the product", title="Capture Ts"
    )
    resolution: PositiveFloat = Field(
        ..., description="Resolution in meters per pixel", title="Resolution"
    )
    product_geometry: PolygonGeomResponse = Field(
        ..., description="GeoJSON polygon geometry with bbox", title="Product Geometry"
    )
    product_area_km2: PositiveFloat = Field(
        ..., description="Product area in square kilometers", title="Product Area Km2"
    )
    status: Status1 = Field(..., title="Status")
    status_reason: Optional[str] = Field(None, title="Status Reason")
    order_state: Optional[OrderState] = Field(None, title="Order State")
    order_reason: Optional[str] = Field(None, title="Order Reason")
    on_behalf_of: Optional[OnBehalfOf] = None


class Status2(Enum):
    invalid = "invalid"
    fulfilling = "fulfilling"
    fulfilled = "fulfilled"


class ResultTaskingResponse(BaseModel):
    id: UUID = Field(..., title="Id")
    intersection_percent_coverage: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Percentage of the request AOI covered by the result",
        title="Intersection Percent Coverage",
    )
    intersection_cloud_percentage: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Percentage of clouds in the request AOI of matching product",
        title="Intersection Cloud Percentage",
    )
    intersection_area_km2: PositiveFloat = Field(
        ...,
        description="Intersection area in square kilometers between the matching product and the request AOI",
        title="Intersection Area Km2",
    )
    price: confloat(ge=0.0) = Field(
        ..., description="Price (USD) of the result", title="Price"
    )
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")
    thumbnail_download_url: Optional[str] = Field(
        None, description="Thumbnail URL of the result", title="Thumbnail Download Url"
    )
    preview_download_url: Optional[str] = Field(
        None, description="Preview URL of the result", title="Preview Download Url"
    )
    intersection_geometry: PolygonGeom = Field(
        ...,
        description="Intersection geometry between the matching product and the search AOI",
        title="Intersection Geometry",
    )
    capture_date: date = Field(
        ..., description="Capture date of the result", title="Capture Date"
    )
    source_name: str = Field(
        ...,
        description="Name of the satellite or constellation that captured the product",
        title="Source Name",
    )
    request_id: UUID = Field(..., description="Request id", title="Request Id")
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Cloud cover percentage of the product's area",
        title="Cloud Cover Percent",
    )
    product_name: str = Field(..., description="Product name", title="Product Name")
    capture_ts: datetime = Field(
        ..., description="Capture timestamp of the product", title="Capture Ts"
    )
    resolution: PositiveFloat = Field(
        ..., description="Resolution in meters per pixel", title="Resolution"
    )
    product_geometry: PolygonGeomResponse = Field(
        ..., description="GeoJSON polygon geometry with bbox", title="Product Geometry"
    )
    product_area_km2: PositiveFloat = Field(
        ..., description="Product area in square kilometers", title="Product Area Km2"
    )
    status: Status2 = Field(..., title="Status")
    status_reason: Optional[str] = Field(None, title="Status Reason")


class ResultsLink(BaseModel):
    results: Link


class ResultsPaginationCursorProductResponse(BaseModel):
    next_cursor: Optional[str] = Field(None, title="Next Cursor")
    total: Optional[int] = Field(None, title="Total")
    results: Optional[List[ProductResponse]] = Field(None, title="Results")


class SecureDownloadResponse(BaseModel):
    download_url: str = Field(..., description="Download url", title="Download Url")


class SensorType2(Enum):
    optical = "optical"
    sar = "sar"


class SourceResponse(BaseModel):
    name: str = Field(
        ..., description="Name of the satellite or constellation", title="Name"
    )
    bands: Optional[str] = Field(
        None,
        description="An ordered list of bands offered by the source",
        title="Bands",
    )
    resolution: PositiveFloat = Field(
        ..., description="Resolution in meters per pixel", title="Resolution"
    )
    sensor_type: Optional[SensorType2] = Field(
        None, description="Type of the sensor", title="Sensor Type"
    )
    id: UUID = Field(..., description="Source id", title="Id")
    deleted: Optional[bool] = Field(False, title="Deleted")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class TenantInfo(BaseModel):
    id: Optional[str] = Field(None, title="Id")
    name: Optional[str] = Field(None, title="Name")


class Token(BaseModel):
    access_token: str = Field(..., title="Access Token")
    id_token: str = Field(..., title="Id Token")
    token_type: str = Field(..., title="Token Type")
    expires_in: int = Field(..., title="Expires In")


class Operation(Enum):
    debit = "debit"
    credit = "credit"


class Type1(Enum):
    order = "order"
    cancellation = "cancellation"
    discount = "discount"


class Tier2(Enum):
    archive = "archive"
    tasking = "tasking"


class UpdatePricePayload(BaseModel):
    source_id: UUID = Field(
        ...,
        description="ID of the satellite or constellation considered for the price",
        title="Source Id",
    )
    price: PositiveFloat = Field(
        ..., description="Price per square kilometer in USD", title="Price"
    )
    tier: Tier2 = Field(..., title="Tier")
    min_age: conint(ge=0) = Field(
        ...,
        description="Minimum age of an ordered product since capture to have this price",
        title="Min Age",
    )
    max_age: Optional[PositiveInt] = Field(
        None,
        description="Maximum age of an product since capture to have this price",
        title="Max Age",
    )


class SensorType3(Enum):
    optical = "optical"
    sar = "sar"


class UpdateSourcePayload(BaseModel):
    name: str = Field(
        ..., description="Name of the satellite or constellation", title="Name"
    )
    bands: Optional[str] = Field(
        None,
        description="An ordered list of bands offered by the source",
        title="Bands",
    )
    resolution: PositiveFloat = Field(
        ..., description="Resolution in meters per pixel", title="Resolution"
    )
    sensor_type: Optional[SensorType3] = Field(
        None, description="Type of the sensor", title="Sensor Type"
    )


class Country1(Enum):
    AFG = "AFG"
    ALA = "ALA"
    ALB = "ALB"
    DZA = "DZA"
    ASM = "ASM"
    AND = "AND"
    AGO = "AGO"
    AIA = "AIA"
    ATA = "ATA"
    ATG = "ATG"
    ARG = "ARG"
    ARM = "ARM"
    ABW = "ABW"
    AUS = "AUS"
    AUT = "AUT"
    AZE = "AZE"
    BHS = "BHS"
    BHR = "BHR"
    BGD = "BGD"
    BRB = "BRB"
    BLR = "BLR"
    BEL = "BEL"
    BLZ = "BLZ"
    BEN = "BEN"
    BMU = "BMU"
    BTN = "BTN"
    BOL = "BOL"
    BES = "BES"
    BIH = "BIH"
    BWA = "BWA"
    BVT = "BVT"
    BRA = "BRA"
    IOT = "IOT"
    VGB = "VGB"
    BRN = "BRN"
    BGR = "BGR"
    BFA = "BFA"
    BDI = "BDI"
    CPV = "CPV"
    KHM = "KHM"
    CMR = "CMR"
    CAN = "CAN"
    CYM = "CYM"
    CAF = "CAF"
    TCD = "TCD"
    CHL = "CHL"
    CHN = "CHN"
    HKG = "HKG"
    MAC = "MAC"
    CXR = "CXR"
    CCK = "CCK"
    COL = "COL"
    COM = "COM"
    COG = "COG"
    COK = "COK"
    CRI = "CRI"
    CIV = "CIV"
    HRV = "HRV"
    CUB = "CUB"
    CUW = "CUW"
    CYP = "CYP"
    CZE = "CZE"
    PRK = "PRK"
    COD = "COD"
    DNK = "DNK"
    DJI = "DJI"
    DMA = "DMA"
    DOM = "DOM"
    ECU = "ECU"
    EGY = "EGY"
    SLV = "SLV"
    GNQ = "GNQ"
    ERI = "ERI"
    EST = "EST"
    SWZ = "SWZ"
    ETH = "ETH"
    FLK = "FLK"
    FRO = "FRO"
    FJI = "FJI"
    FIN = "FIN"
    FRA = "FRA"
    GUF = "GUF"
    PYF = "PYF"
    ATF = "ATF"
    GAB = "GAB"
    GMB = "GMB"
    GEO = "GEO"
    DEU = "DEU"
    GHA = "GHA"
    GIB = "GIB"
    GRC = "GRC"
    GRL = "GRL"
    GRD = "GRD"
    GLP = "GLP"
    GUM = "GUM"
    GTM = "GTM"
    GGY = "GGY"
    GIN = "GIN"
    GNB = "GNB"
    GUY = "GUY"
    HTI = "HTI"
    HMD = "HMD"
    VAT = "VAT"
    HND = "HND"
    HUN = "HUN"
    ISL = "ISL"
    IND = "IND"
    IDN = "IDN"
    IRN = "IRN"
    IRQ = "IRQ"
    IRL = "IRL"
    IMN = "IMN"
    ISR = "ISR"
    ITA = "ITA"
    JAM = "JAM"
    JPN = "JPN"
    JEY = "JEY"
    JOR = "JOR"
    KAZ = "KAZ"
    KEN = "KEN"
    KIR = "KIR"
    KWT = "KWT"
    KGZ = "KGZ"
    LAO = "LAO"
    LVA = "LVA"
    LBN = "LBN"
    LSO = "LSO"
    LBR = "LBR"
    LBY = "LBY"
    LIE = "LIE"
    LTU = "LTU"
    LUX = "LUX"
    MDG = "MDG"
    MWI = "MWI"
    MYS = "MYS"
    MDV = "MDV"
    MLI = "MLI"
    MLT = "MLT"
    MHL = "MHL"
    MTQ = "MTQ"
    MRT = "MRT"
    MUS = "MUS"
    MYT = "MYT"
    MEX = "MEX"
    FSM = "FSM"
    MCO = "MCO"
    MNG = "MNG"
    MNE = "MNE"
    MSR = "MSR"
    MAR = "MAR"
    MOZ = "MOZ"
    MMR = "MMR"
    NAM = "NAM"
    NRU = "NRU"
    NPL = "NPL"
    NLD = "NLD"
    NCL = "NCL"
    NZL = "NZL"
    NIC = "NIC"
    NER = "NER"
    NGA = "NGA"
    NIU = "NIU"
    NFK = "NFK"
    MKD = "MKD"
    MNP = "MNP"
    NOR = "NOR"
    OMN = "OMN"
    PAK = "PAK"
    PLW = "PLW"
    PAN = "PAN"
    PNG = "PNG"
    PRY = "PRY"
    PER = "PER"
    PHL = "PHL"
    PCN = "PCN"
    POL = "POL"
    PRT = "PRT"
    PRI = "PRI"
    QAT = "QAT"
    KOR = "KOR"
    MDA = "MDA"
    REU = "REU"
    ROU = "ROU"
    RUS = "RUS"
    RWA = "RWA"
    BLM = "BLM"
    SHN = "SHN"
    KNA = "KNA"
    LCA = "LCA"
    MAF = "MAF"
    SPM = "SPM"
    VCT = "VCT"
    WSM = "WSM"
    SMR = "SMR"
    STP = "STP"
    SAU = "SAU"
    SEN = "SEN"
    SRB = "SRB"
    SYC = "SYC"
    SLE = "SLE"
    SGP = "SGP"
    SXM = "SXM"
    SVK = "SVK"
    SVN = "SVN"
    SLB = "SLB"
    SOM = "SOM"
    ZAF = "ZAF"
    SGS = "SGS"
    SSD = "SSD"
    ESP = "ESP"
    LKA = "LKA"
    PSE = "PSE"
    SDN = "SDN"
    SUR = "SUR"
    SJM = "SJM"
    SWE = "SWE"
    CHE = "CHE"
    SYR = "SYR"
    TJK = "TJK"
    THA = "THA"
    TLS = "TLS"
    TGO = "TGO"
    TKL = "TKL"
    TON = "TON"
    TTO = "TTO"
    TUN = "TUN"
    TUR = "TUR"
    TKM = "TKM"
    TCA = "TCA"
    TUV = "TUV"
    UGA = "UGA"
    UKR = "UKR"
    ARE = "ARE"
    GBR = "GBR"
    TZA = "TZA"
    UMI = "UMI"
    USA = "USA"
    VIR = "VIR"
    URY = "URY"
    UZB = "UZB"
    VUT = "VUT"
    VEN = "VEN"
    VNM = "VNM"
    WLF = "WLF"
    ESH = "ESH"
    YEM = "YEM"
    ZMB = "ZMB"
    ZWE = "ZWE"


class UpdateUserAdminPayload(BaseModel):
    full_name: Optional[str] = Field(None, title="Full Name")
    phone_number: Optional[constr(regex=r"(^\+?\d{5,15}$)|^$")] = Field(
        None, title="Phone Number"
    )
    country: Optional[Country1] = Field(None, title="Country")
    is_active: Optional[bool] = Field(None, title="Is Active")


class Country2(Enum):
    AFG = "AFG"
    ALA = "ALA"
    ALB = "ALB"
    DZA = "DZA"
    ASM = "ASM"
    AND = "AND"
    AGO = "AGO"
    AIA = "AIA"
    ATA = "ATA"
    ATG = "ATG"
    ARG = "ARG"
    ARM = "ARM"
    ABW = "ABW"
    AUS = "AUS"
    AUT = "AUT"
    AZE = "AZE"
    BHS = "BHS"
    BHR = "BHR"
    BGD = "BGD"
    BRB = "BRB"
    BLR = "BLR"
    BEL = "BEL"
    BLZ = "BLZ"
    BEN = "BEN"
    BMU = "BMU"
    BTN = "BTN"
    BOL = "BOL"
    BES = "BES"
    BIH = "BIH"
    BWA = "BWA"
    BVT = "BVT"
    BRA = "BRA"
    IOT = "IOT"
    VGB = "VGB"
    BRN = "BRN"
    BGR = "BGR"
    BFA = "BFA"
    BDI = "BDI"
    CPV = "CPV"
    KHM = "KHM"
    CMR = "CMR"
    CAN = "CAN"
    CYM = "CYM"
    CAF = "CAF"
    TCD = "TCD"
    CHL = "CHL"
    CHN = "CHN"
    HKG = "HKG"
    MAC = "MAC"
    CXR = "CXR"
    CCK = "CCK"
    COL = "COL"
    COM = "COM"
    COG = "COG"
    COK = "COK"
    CRI = "CRI"
    CIV = "CIV"
    HRV = "HRV"
    CUB = "CUB"
    CUW = "CUW"
    CYP = "CYP"
    CZE = "CZE"
    PRK = "PRK"
    COD = "COD"
    DNK = "DNK"
    DJI = "DJI"
    DMA = "DMA"
    DOM = "DOM"
    ECU = "ECU"
    EGY = "EGY"
    SLV = "SLV"
    GNQ = "GNQ"
    ERI = "ERI"
    EST = "EST"
    SWZ = "SWZ"
    ETH = "ETH"
    FLK = "FLK"
    FRO = "FRO"
    FJI = "FJI"
    FIN = "FIN"
    FRA = "FRA"
    GUF = "GUF"
    PYF = "PYF"
    ATF = "ATF"
    GAB = "GAB"
    GMB = "GMB"
    GEO = "GEO"
    DEU = "DEU"
    GHA = "GHA"
    GIB = "GIB"
    GRC = "GRC"
    GRL = "GRL"
    GRD = "GRD"
    GLP = "GLP"
    GUM = "GUM"
    GTM = "GTM"
    GGY = "GGY"
    GIN = "GIN"
    GNB = "GNB"
    GUY = "GUY"
    HTI = "HTI"
    HMD = "HMD"
    VAT = "VAT"
    HND = "HND"
    HUN = "HUN"
    ISL = "ISL"
    IND = "IND"
    IDN = "IDN"
    IRN = "IRN"
    IRQ = "IRQ"
    IRL = "IRL"
    IMN = "IMN"
    ISR = "ISR"
    ITA = "ITA"
    JAM = "JAM"
    JPN = "JPN"
    JEY = "JEY"
    JOR = "JOR"
    KAZ = "KAZ"
    KEN = "KEN"
    KIR = "KIR"
    KWT = "KWT"
    KGZ = "KGZ"
    LAO = "LAO"
    LVA = "LVA"
    LBN = "LBN"
    LSO = "LSO"
    LBR = "LBR"
    LBY = "LBY"
    LIE = "LIE"
    LTU = "LTU"
    LUX = "LUX"
    MDG = "MDG"
    MWI = "MWI"
    MYS = "MYS"
    MDV = "MDV"
    MLI = "MLI"
    MLT = "MLT"
    MHL = "MHL"
    MTQ = "MTQ"
    MRT = "MRT"
    MUS = "MUS"
    MYT = "MYT"
    MEX = "MEX"
    FSM = "FSM"
    MCO = "MCO"
    MNG = "MNG"
    MNE = "MNE"
    MSR = "MSR"
    MAR = "MAR"
    MOZ = "MOZ"
    MMR = "MMR"
    NAM = "NAM"
    NRU = "NRU"
    NPL = "NPL"
    NLD = "NLD"
    NCL = "NCL"
    NZL = "NZL"
    NIC = "NIC"
    NER = "NER"
    NGA = "NGA"
    NIU = "NIU"
    NFK = "NFK"
    MKD = "MKD"
    MNP = "MNP"
    NOR = "NOR"
    OMN = "OMN"
    PAK = "PAK"
    PLW = "PLW"
    PAN = "PAN"
    PNG = "PNG"
    PRY = "PRY"
    PER = "PER"
    PHL = "PHL"
    PCN = "PCN"
    POL = "POL"
    PRT = "PRT"
    PRI = "PRI"
    QAT = "QAT"
    KOR = "KOR"
    MDA = "MDA"
    REU = "REU"
    ROU = "ROU"
    RUS = "RUS"
    RWA = "RWA"
    BLM = "BLM"
    SHN = "SHN"
    KNA = "KNA"
    LCA = "LCA"
    MAF = "MAF"
    SPM = "SPM"
    VCT = "VCT"
    WSM = "WSM"
    SMR = "SMR"
    STP = "STP"
    SAU = "SAU"
    SEN = "SEN"
    SRB = "SRB"
    SYC = "SYC"
    SLE = "SLE"
    SGP = "SGP"
    SXM = "SXM"
    SVK = "SVK"
    SVN = "SVN"
    SLB = "SLB"
    SOM = "SOM"
    ZAF = "ZAF"
    SGS = "SGS"
    SSD = "SSD"
    ESP = "ESP"
    LKA = "LKA"
    PSE = "PSE"
    SDN = "SDN"
    SUR = "SUR"
    SJM = "SJM"
    SWE = "SWE"
    CHE = "CHE"
    SYR = "SYR"
    TJK = "TJK"
    THA = "THA"
    TLS = "TLS"
    TGO = "TGO"
    TKL = "TKL"
    TON = "TON"
    TTO = "TTO"
    TUN = "TUN"
    TUR = "TUR"
    TKM = "TKM"
    TCA = "TCA"
    TUV = "TUV"
    UGA = "UGA"
    UKR = "UKR"
    ARE = "ARE"
    GBR = "GBR"
    TZA = "TZA"
    UMI = "UMI"
    USA = "USA"
    VIR = "VIR"
    URY = "URY"
    UZB = "UZB"
    VUT = "VUT"
    VEN = "VEN"
    VNM = "VNM"
    WLF = "WLF"
    ESH = "ESH"
    YEM = "YEM"
    ZMB = "ZMB"
    ZWE = "ZWE"


class UpdateUserPayload(BaseModel):
    full_name: Optional[str] = Field(None, title="Full Name")
    phone_number: Optional[constr(regex=r"(^\+?\d{5,15}$)|^$")] = Field(
        None, title="Phone Number"
    )
    country: Optional[Country2] = Field(None, title="Country")


class UploadParts(BaseModel):
    etag: str = Field(
        ...,
        description="Etag id that identifies when the part was uploaded",
        title="Etag",
    )
    part_number: int = Field(
        ..., description="Part number that identifies the part", title="Part Number"
    )


class User(BaseModel):
    id: Optional[UUID] = Field(None, title="Id")
    email: Optional[EmailStr] = Field(None, title="Email")
    is_active: Optional[bool] = Field(True, title="Is Active")
    full_name: Optional[str] = Field(None, title="Full Name")
    roles: Optional[List] = Field([], title="Roles", unique_items=True)
    phone_number: Optional[str] = Field(None, title="Phone Number")
    country: Optional[str] = Field(None, title="Country")
    tenant: Optional[TenantInfo] = None


class UserInfo(BaseModel):
    id: UUID = Field(..., description="Unique identifier for the user", title="Id")
    email: EmailStr = Field(..., description="Email of the user", title="Email")


class ValidationError(BaseModel):
    loc: List[str] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class CreateRequestArchivePayload(BaseModel):
    start_date: date = Field(
        ..., description="Earliest allowable date of capture", title="Start Date"
    )
    end_date: date = Field(
        ..., description="Latest allowable date of capture", title="End Date"
    )
    callback: Optional[Callback] = Field(
        None,
        description="JSON object that contains information on where to push notifications for any updates on the request",
        title="Callback",
    )
    on_behalf_of: Optional[OnBehalfOf] = None
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        80,
        description="Maximum allowable cloud cover percentage",
        title="Cloud Cover Percent",
    )
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry", title="Geometry"
    )
    tags: Optional[Dict[str, Any]] = Field(
        {}, description="Custom key-value pairs for tagging and filtering", title="Tags"
    )
    sources: Optional[List[str]] = Field(
        None,
        description="List of satellite or constellation names that captured the product. If the list is not set, it considers all available sources.",
        max_items=20,
        title="Sources",
    )
    sensor_type: Optional[SensorType] = Field(
        None, description="Satellite or constellation sensor type", title="Sensor Type"
    )
    min_resolution: PositiveFloat = Field(
        ...,
        description="Lowest allowable resolution in meters per pixel (higher value means lower resolution)",
        title="Min Resolution",
    )
    max_resolution: PositiveFloat = Field(
        ...,
        description="Best allowable resolution in meters per pixel (lower value means better resolution)",
        title="Max Resolution",
    )


class CreateRequestArchiveResponse(BaseModel):
    data: RequestArchiveResponse = Field(
        ..., description="The request data", title="Data"
    )
    _links: ResultsLink = Field(
        ..., description="Additional links related to this endpoint", title=" Links"
    )


class CreateRequestTaskingPayload(BaseModel):
    start_date: date = Field(
        ..., description="Earliest allowable date of capture", title="Start Date"
    )
    end_date: date = Field(
        ..., description="Latest allowable date of capture", title="End Date"
    )
    callback: Optional[Callback] = Field(
        None,
        description="JSON object that contains information on where to push notifications for any updates on the request",
        title="Callback",
    )
    on_behalf_of: Optional[OnBehalfOf] = None
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        80,
        description="Maximum allowable cloud cover percentage",
        title="Cloud Cover Percent",
    )
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry", title="Geometry"
    )
    tags: Optional[Dict[str, Any]] = Field(
        {}, description="Custom key-value pairs for tagging and filtering", title="Tags"
    )
    aoi_intersection_percent: Optional[confloat(ge=0.1, le=100.0)] = Field(
        85,
        description="Minimum expected AOI intersection percentage to be fulfilled",
        title="Aoi Intersection Percent",
    )
    output: Optional[OutputTasking] = Field(
        {"multi_product": True}, title="Product output options"
    )
    source_name: str = Field(
        ...,
        description="Name of the satellite or constellation that captured the product",
        title="Source Name",
    )


class FulfillProductPayload(BaseModel):
    id: Optional[UUID] = Field(None, title="Id")
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry", title="Geometry"
    )
    source_id: UUID = Field(
        ...,
        description="ID of the satellite or constellation that captured the product",
        title="Source Id",
    )
    name: str = Field(..., description="Product name", title="Name")
    area_km2: Optional[confloat(ge=0.0)] = Field(
        None,
        description="Size of the product's area in square kilometers",
        title="Area Km2",
    )
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description="Cloud cover percentage of the product's area",
        title="Cloud Cover Percent",
    )
    capture_ts: datetime = Field(
        ..., description="Capture timestamp of the product", title="Capture Ts"
    )
    capture_date: date = Field(
        ..., description="Capture date of the product", title="Capture Date"
    )
    preview_download_url: str = Field(
        ..., description="Preview URL of the product", title="Preview Download Url"
    )
    thumbnail_download_url: str = Field(
        ..., description="Thumbnail URL of the product", title="Thumbnail Download Url"
    )
    height_pixels: Optional[PositiveInt] = Field(
        None, description="Height in pixels of the actual image", title="Height Pixels"
    )
    width_pixels: Optional[PositiveInt] = Field(
        None, description="Width in pixels of the actual image", title="Width Pixels"
    )
    created_at: Optional[datetime] = Field(None, title="Created At")
    updated_at: Optional[datetime] = Field(None, title="Updated At")
    level: Optional[str] = Field(
        None, description="Remote sensing imagery processing level", title="Level"
    )
    download_url: str = Field(
        ..., description="Download URL of the product", title="Download Url"
    )


class GetRequestArchiveResponse(BaseModel):
    data: RequestArchiveResponse = Field(
        ..., description="The request data", title="Data"
    )
    _links: ResultsLink = Field(
        ..., description="Additional links related to this endpoint", title=" Links"
    )


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title="Detail")


class ListPriceResponse(BaseModel):
    data: List[PriceResponse] = Field(..., description="Array of prices", title="Data")
    pagination: CursorPaginationResponse = Field(
        ..., description="Pagination information", title="Pagination"
    )


class ListRequestArchiveResponse(BaseModel):
    data: List[RequestArchive] = Field(
        ..., description="Array of archive requests", title="Data"
    )
    pagination: CursorPaginationResponse = Field(
        ..., description="Pagination information", title="Pagination"
    )


class ListResultArchiveResponse(BaseModel):
    data: List[ResultArchiveResponse] = Field(
        ..., description="Array of archive results", title="Data"
    )
    pagination: CursorPaginationResponse = Field(
        ..., description="Pagination information", title="Pagination"
    )


class ListResultTaskingResponse(BaseModel):
    data: List[ResultTaskingResponse] = Field(
        ..., description="Array of tasking results", title="Data"
    )
    pagination: CursorPaginationResponse = Field(
        ..., description="Pagination information", title="Pagination"
    )


class ListUsersResponse(BaseModel):
    data: List[User] = Field(..., description="Array of users", title="Data")
    cursor: str = Field(
        ..., description="Next cursor to fetch more users", title="Cursor"
    )


class ProductUploadCompletePayload(BaseModel):
    upload_id: str = Field(
        ...,
        description="Multipart upload id that refers to the product upload initiated",
        title="Upload Id",
    )
    request_id: str = Field(
        ..., description="Request id that originated the order", title="Request Id"
    )
    result_id: str = Field(
        ...,
        description="Result id created as part of the order request",
        title="Result Id",
    )
    type: Type = Field(
        ..., description="Type of the request, archive or tasking", title="Type"
    )
    parts: List[UploadParts] = Field(
        ...,
        description="Parts information required to confirm product upload",
        title="Parts",
    )


class RequestTaskingResponse(BaseModel):
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry", title="Geometry"
    )
    id: UUID = Field(..., title="Id")
    start_date: date = Field(
        ..., description="Earliest allowable date of capture", title="Start Date"
    )
    end_date: date = Field(
        ..., description="Latest allowable date of capture", title="End Date"
    )
    area_km2: PositiveFloat = Field(
        ..., description="Geometry area in square kilometers", title="Area Km2"
    )
    fulfilled_area_km2: Optional[PositiveFloat] = Field(
        None,
        description="Total area in square kilometers of all results that fulfill the request",
        title="Fulfilled Area Km2",
    )
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")
    callback: Optional[Callback] = Field(
        None,
        description="JSON object that contains information on where to push notifications for any updates on the request",
        title="Callback",
    )
    cloud_cover_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        20,
        description="Maximum allowable cloud cover percentage",
        title="Cloud Cover Percent",
    )
    hidden: bool = Field(..., title="Hidden")
    user_id: UUID = Field(..., title="User Id")
    on_behalf_of: Optional[OnBehalfOf] = None
    tags: Optional[Dict[str, Any]] = Field(
        {}, description="Custom key-value pairs for tagging and filtering", title="Tags"
    )
    status: Optional[Status] = Field("quoted", title="Status")
    status_reason: Optional[str] = Field(
        None,
        description="Indicate the reason for tasking request status.",
        title="Status Reason",
    )
    ordered: Optional[bool] = Field(
        False, description="Indicates if the request was ordered", title="Ordered"
    )
    aoi_intersection_percent: float = Field(
        ...,
        description="Minimum expected AOI intersection percentage to be fulfilled",
        title="Aoi Intersection Percent",
    )
    commitment_ts: Optional[datetime] = Field(
        None,
        description="The timestamp until when a request that's approved or scheduled for collection can still be cancelled",
        title="Commitment Ts",
    )
    expiration_ts: datetime = Field(
        ...,
        description="The timestamp until when a quoted request can be ordered by the customer (see Order Tasking Request) and approved by the operator (see Approve Tasking Order)",
        title="Expiration Ts",
    )
    results: Optional[List[ResultTaskingResponse]] = Field(
        [],
        description="List of results for the tasking request. Will be populated as captures are made.",
        title="Results",
    )
    output: OutputTasking = Field(..., title="Product output options")
    source_name: str = Field(
        ...,
        description="Name of the satellite or constellation that captured the product",
        title="Source Name",
    )
    price: float = Field(
        ...,
        description="Estimated price quote for newly created tasking requests",
        title="Price",
    )


class TransactionResponse(BaseModel):
    id: UUID = Field(
        ..., description="Unique identifier for the transaction", title="Id"
    )
    created_at: datetime = Field(
        ...,
        description="The UTC date and time the transaction was created",
        title="Created At",
    )
    operation: Operation = Field(
        ...,
        description="The operation that originates the transaction",
        title="Operation",
    )
    type: Type1 = Field(..., description="The type of the transaction", title="Type")
    description: Optional[str] = Field(
        None, description="The description of the transaction", title="Description"
    )
    amount: confloat(ge=0.0) = Field(
        ...,
        description="Price or discount amount depending on the transaction operation",
        title="Amount",
    )
    order: Optional[OrderInfo] = Field(
        None, description="Order information related to this transaction", title="Order"
    )
    user: UserInfo = Field(
        ..., description="User information related to this transaction", title="User"
    )


class ListRequestTaskingResponse(BaseModel):
    data: List[RequestTaskingResponse] = Field(
        ..., description="Array of tasking requests", title="Data"
    )
    pagination: CursorPaginationResponse = Field(
        ..., description="Pagination information", title="Pagination"
    )


class ListTransactionResponse(BaseModel):
    data: List[TransactionResponse] = Field(
        ..., description="Array of transactions", title="Data"
    )
    pagination: CursorPaginationResponse = Field(
        ..., description="Pagination information", title="Pagination"
    )


class ProductProperties(BaseModel):
    name: str = Field(..., description="Product name", title="Name")
    capture_ts: datetime = Field(
        ..., description="Capture timestamp of the product", title="Capture Ts"
    )
    source_name: str = Field(
        ...,
        description="Name of the satellite or constellation that captured the product",
        title="Source Name",
    )
    num_parts: Optional[PositiveInt] = Field(
        1,
        description="Number of parts the file to upload will be splitted",
        title="Num Parts",
    )


class CreateCustomProductPayload(BaseModel):
    geometry: PolygonGeom = Field(
        ..., description="GeoJSON polygon geometry of product", title="Geometry"
    )
    properties: ProductProperties = Field(
        ..., description="Product properties", title="Properties"
    )
    type: str = Field(..., description="Type of request", title="Type")
    request_id: UUID = Field(
        ..., description="Unique identifier for the Request", title="Request Id"
    )
    result_id: Optional[UUID] = Field(
        None,
        description="Unique identifier for the Result - only valid for Archive requests",
        title="Result Id",
    )
    fetch_code: str = Field(
        ..., description="Order id provided by the supplier", title="Fetch Code"
    )


class CustomProductResponse(BaseModel):
    product_id: UUID = Field(
        ..., description="Unique identifier for the Product", title="Product Id"
    )
    result_id: UUID = Field(
        ..., description="Unique identifier for the Result", title="Result Id"
    )
    upload_id: str = Field(
        ..., description="Unique identifier for the upload", title="Multipart Upload Id"
    )
    upload_urls: List = Field(
        ..., description="List of generated urls", title="Upload Urls"
    )
